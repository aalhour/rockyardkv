package manifest

import (
	"bytes"
	"os"
	"path/filepath"
	"testing"

	"github.com/aalhour/rockyardkv/internal/wal"
)

// TestGoldenManifestSimple tests reading a simple MANIFEST file generated by RocksDB v10.7.5.
// The file contains VersionEdits with comparator name, log number, next file number, and last sequence.
func TestGoldenManifestSimple(t *testing.T) {
	goldenPath := filepath.Join("..", "..", "testdata", "golden", "v10.7.5", "manifest", "simple.manifest")
	data, err := os.ReadFile(goldenPath)
	if err != nil {
		t.Skipf("Golden file not found: %v (run golden fixture generation first)", err)
	}

	// MANIFEST files are written as log records (same format as WAL)
	reader := wal.NewReader(bytes.NewReader(data), nil, true /* checksum */, 0 /* log_num */)

	editCount := 0
	for {
		record, err := reader.ReadRecord()
		if err != nil {
			break
		}

		edit := &VersionEdit{}
		if err := edit.DecodeFrom(record); err != nil {
			t.Fatalf("Failed to decode VersionEdit %d: %v", editCount, err)
		}

		t.Logf("VersionEdit %d:", editCount)
		if edit.HasComparator {
			t.Logf("  Comparator: %s", edit.Comparator)
		}
		if edit.HasLogNumber {
			t.Logf("  LogNumber: %d", edit.LogNumber)
		}
		if edit.HasNextFileNumber {
			t.Logf("  NextFileNumber: %d", edit.NextFileNumber)
		}
		if edit.HasLastSequence {
			t.Logf("  LastSequence: %d", edit.LastSequence)
		}
		if edit.HasColumnFamily {
			t.Logf("  ColumnFamily: %d", edit.ColumnFamily)
		}
		t.Logf("  NewFiles: %d, DeletedFiles: %d", len(edit.NewFiles), len(edit.DeletedFiles))

		editCount++
	}

	if editCount == 0 {
		t.Fatal("No VersionEdits found in MANIFEST")
	}

	t.Logf("Total VersionEdits: %d", editCount)
}

// TestGoldenManifestNewFile tests reading a MANIFEST with NewFile4 entries.
func TestGoldenManifestNewFile(t *testing.T) {
	goldenPath := filepath.Join("..", "..", "testdata", "golden", "v10.7.5", "manifest", "newfile.manifest")
	data, err := os.ReadFile(goldenPath)
	if err != nil {
		t.Skipf("Golden file not found: %v (run golden fixture generation first)", err)
	}

	reader := wal.NewReader(bytes.NewReader(data), nil, true /* checksum */, 0 /* log_num */)

	foundNewFile := false
	editCount := 0

	for {
		record, err := reader.ReadRecord()
		if err != nil {
			break
		}

		edit := &VersionEdit{}
		if err := edit.DecodeFrom(record); err != nil {
			t.Fatalf("Failed to decode VersionEdit %d: %v", editCount, err)
		}

		if len(edit.NewFiles) > 0 {
			foundNewFile = true
			for _, nf := range edit.NewFiles {
				t.Logf("NewFile at level %d:", nf.Level)
				t.Logf("  FileNumber: %d", nf.Meta.FD.GetNumber())
				t.Logf("  FileSize: %d", nf.Meta.FD.FileSize)
				t.Logf("  SmallestSeqno: %d", nf.Meta.FD.SmallestSeqno)
				t.Logf("  LargestSeqno: %d", nf.Meta.FD.LargestSeqno)
				if len(nf.Meta.Smallest) > 0 {
					t.Logf("  SmallestKey: %x", nf.Meta.Smallest)
				}
				if len(nf.Meta.Largest) > 0 {
					t.Logf("  LargestKey: %x", nf.Meta.Largest)
				}
			}
		}

		editCount++
	}

	if !foundNewFile {
		t.Error("Expected to find at least one NewFile entry")
	}

	t.Logf("Total VersionEdits: %d", editCount)
}

// TestGoldenManifestRoundTrip verifies our encoder produces output that our decoder can parse.
func TestGoldenManifestRoundTrip(t *testing.T) {
	testCases := []struct {
		name string
		edit *VersionEdit
	}{
		{
			name: "basic edit",
			edit: &VersionEdit{
				HasComparator:     true,
				Comparator:        "leveldb.BytewiseComparator",
				HasLogNumber:      true,
				LogNumber:         100,
				HasNextFileNumber: true,
				NextFileNumber:    200,
				HasLastSequence:   true,
				LastSequence:      1000,
			},
		},
		{
			name: "with column family",
			edit: &VersionEdit{
				HasColumnFamily:   true,
				ColumnFamily:      1,
				IsColumnFamilyAdd: true,
				ColumnFamilyName:  "test_cf",
				HasComparator:     true,
				Comparator:        "leveldb.BytewiseComparator",
			},
		},
		{
			name: "with deleted file",
			edit: &VersionEdit{
				DeletedFiles: []DeletedFileEntry{
					{Level: 0, FileNumber: 100},
					{Level: 1, FileNumber: 200},
				},
			},
		},
		{
			name: "with new file",
			edit: func() *VersionEdit {
				meta := NewFileMetaData()
				meta.FD = NewFileDescriptor(100, 0, 10000)
				meta.Smallest = []byte("key001")
				meta.Largest = []byte("key999")
				meta.FD.SmallestSeqno = 1
				meta.FD.LargestSeqno = 100
				meta.EpochNumber = 1

				return &VersionEdit{
					NewFiles: []NewFileEntry{
						{Level: 2, Meta: meta},
					},
				}
			}(),
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Encode
			encoded := tc.edit.EncodeTo()

			// Decode
			decoded := &VersionEdit{}
			if err := decoded.DecodeFrom(encoded); err != nil {
				t.Fatalf("DecodeFrom failed: %v", err)
			}

			// Verify key fields match
			if tc.edit.HasComparator {
				if !decoded.HasComparator || decoded.Comparator != tc.edit.Comparator {
					t.Errorf("Comparator mismatch: got %q, want %q", decoded.Comparator, tc.edit.Comparator)
				}
			}
			if tc.edit.HasLogNumber {
				if !decoded.HasLogNumber || decoded.LogNumber != tc.edit.LogNumber {
					t.Errorf("LogNumber mismatch: got %d, want %d", decoded.LogNumber, tc.edit.LogNumber)
				}
			}
			if tc.edit.HasNextFileNumber {
				if !decoded.HasNextFileNumber || decoded.NextFileNumber != tc.edit.NextFileNumber {
					t.Errorf("NextFileNumber mismatch: got %d, want %d", decoded.NextFileNumber, tc.edit.NextFileNumber)
				}
			}
			if tc.edit.HasLastSequence {
				if !decoded.HasLastSequence || decoded.LastSequence != tc.edit.LastSequence {
					t.Errorf("LastSequence mismatch: got %d, want %d", decoded.LastSequence, tc.edit.LastSequence)
				}
			}
			if len(tc.edit.DeletedFiles) > 0 {
				if len(decoded.DeletedFiles) != len(tc.edit.DeletedFiles) {
					t.Errorf("DeletedFiles count mismatch: got %d, want %d", len(decoded.DeletedFiles), len(tc.edit.DeletedFiles))
				}
			}
			if len(tc.edit.NewFiles) > 0 {
				if len(decoded.NewFiles) != len(tc.edit.NewFiles) {
					t.Errorf("NewFiles count mismatch: got %d, want %d", len(decoded.NewFiles), len(tc.edit.NewFiles))
				}
			}
		})
	}
}
