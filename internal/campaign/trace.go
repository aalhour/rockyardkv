// trace.go implements trace capture and argument injection for stresstest.
//
// When trace capture is enabled, the runner injects -trace-out and -trace-max-size
// arguments into stresstest invocations to capture operation traces for debugging.
package campaign

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// TraceConfig defines trace capture behavior for campaign runs.
type TraceConfig struct {
	// Enabled controls whether trace capture is active.
	Enabled bool

	// MaxSizeBytes is the maximum trace file size before truncation.
	// Default: 256MB (256 * 1024 * 1024).
	MaxSizeBytes int64

	// TraceDir is the subdirectory under the run directory for trace files.
	// Default: "trace".
	TraceDir string
}

// DefaultTraceConfig returns the default trace configuration.
func DefaultTraceConfig() TraceConfig {
	return TraceConfig{
		Enabled:      false,
		MaxSizeBytes: 256 * 1024 * 1024, // 256MB
		TraceDir:     "trace",
	}
}

// TraceResult captures the outcome of trace handling for a run.
type TraceResult struct {
	// Path is the path to the trace file (if captured).
	Path string

	// BytesWritten is the number of bytes written to the trace file.
	BytesWritten int64

	// Truncated indicates if the trace was truncated due to size limits.
	Truncated bool

	// ReplayCommand is the command to replay this trace.
	ReplayCommand string
}

// TracePaths returns the paths for trace artifacts in a run directory.
func TracePaths(runDir string, config TraceConfig) (traceFile, truncatedMarker string) {
	traceDir := filepath.Join(runDir, config.TraceDir)
	traceFile = filepath.Join(traceDir, "ops.bin")
	truncatedMarker = filepath.Join(traceDir, "truncated.txt")
	return
}

// EnsureTraceDir creates the trace directory if trace capture is enabled.
func EnsureTraceDir(runDir string, config TraceConfig) error {
	if !config.Enabled {
		return nil
	}
	traceDir := filepath.Join(runDir, config.TraceDir)
	return os.MkdirAll(traceDir, 0o755)
}

// InjectTraceArgs adds -trace-out and -trace-max-size to the argument list if not already present.
// Returns the modified args and the trace file path.
// If -trace-out is already specified (either as "-trace-out <path>" or "-trace-out=<path>"),
// returns the existing path without modification (but still injects -trace-max-size if missing).
func InjectTraceArgs(args []string, runDir string, config TraceConfig) ([]string, string) {
	if !config.Enabled {
		return args, ""
	}

	result := args
	var tracePath string

	// Check if -trace-out is already specified (either "-trace-out" or "-trace-out=...")
	traceOutPresent := false
	for i, arg := range args {
		if arg == "-trace-out" {
			traceOutPresent = true
			if i+1 < len(args) {
				tracePath = args[i+1]
			}
			break
		}
		if path, found := strings.CutPrefix(arg, "-trace-out="); found {
			traceOutPresent = true
			tracePath = path
			break
		}
	}

	// Inject -trace-out if not present
	if !traceOutPresent {
		traceFile, _ := TracePaths(runDir, config)
		result = append(result, "-trace-out", traceFile)
		tracePath = traceFile
	}

	// Check if -trace-max-size is already specified
	maxSizePresent := false
	for _, arg := range args {
		if arg == "-trace-max-size" || strings.HasPrefix(arg, "-trace-max-size=") {
			maxSizePresent = true
			break
		}
	}

	// Inject -trace-max-size if not present and config has a limit
	if !maxSizePresent && config.MaxSizeBytes > 0 {
		result = append(result, "-trace-max-size", fmt.Sprintf("%d", config.MaxSizeBytes))
	}

	return result, tracePath
}

// CheckTraceSize checks if a trace file exists and its size.
// Returns the size and whether it exceeds the limit.
func CheckTraceSize(tracePath string, config TraceConfig) (size int64, exceeded bool, err error) {
	info, err := os.Stat(tracePath)
	if err != nil {
		if os.IsNotExist(err) {
			return 0, false, nil
		}
		return 0, false, err
	}

	size = info.Size()
	exceeded = size > config.MaxSizeBytes
	return size, exceeded, nil
}

// WriteTruncatedMarker writes a marker file indicating trace truncation.
func WriteTruncatedMarker(runDir string, config TraceConfig, bytesWritten int64) error {
	_, markerPath := TracePaths(runDir, config)

	content := fmt.Sprintf("Trace truncated at %d bytes (limit: %d bytes)\n",
		bytesWritten, config.MaxSizeBytes)

	return os.WriteFile(markerPath, []byte(content), 0o644)
}

// BuildReplayCommand generates the traceanalyzer replay command for a trace file.
func BuildReplayCommand(tracePath, dbPath, binDir string) string {
	analyzer := filepath.Join(binDir, "traceanalyzer")
	// Quote paths for shell safety (handles spaces in paths)
	return fmt.Sprintf("%q -db %q -create=true replay %q", analyzer, dbPath, tracePath)
}

// WriteReplayScript writes a replay.sh script to the run directory.
func WriteReplayScript(runDir, tracePath, dbPath, binDir string) error {
	replayCmd := BuildReplayCommand(tracePath, dbPath, binDir)

	script := fmt.Sprintf(`#!/bin/bash
# Replay trace to reproduce the test run
# Generated by campaignrunner

set -euo pipefail

%s
`, replayCmd)

	scriptPath := filepath.Join(runDir, "replay.sh")
	if err := os.WriteFile(scriptPath, []byte(script), 0o755); err != nil {
		return fmt.Errorf("write replay script: %w", err)
	}
	return nil
}

// CollectTraceResult gathers trace information after a run completes.
func CollectTraceResult(runDir, dbPath, binDir string, config TraceConfig) *TraceResult {
	if !config.Enabled {
		return nil
	}

	tracePath, markerPath := TracePaths(runDir, config)

	result := &TraceResult{
		Path: tracePath,
	}

	// Check if trace file exists
	info, err := os.Stat(tracePath)
	if err != nil {
		return nil // No trace file
	}
	result.BytesWritten = info.Size()

	// Check for truncation marker
	if _, err := os.Stat(markerPath); err == nil {
		result.Truncated = true
	}

	// Build replay command
	if dbPath != "" {
		result.ReplayCommand = BuildReplayCommand(tracePath, dbPath, binDir)
	}

	return result
}
