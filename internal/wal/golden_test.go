package wal

import (
	"bytes"
	"os"
	"path/filepath"
	"testing"
)

// TestGoldenWALSimple tests reading a simple WAL file generated by RocksDB v10.7.5.
// The file contains a single WriteBatch with key3=value3.
func TestGoldenWALSimple(t *testing.T) {
	goldenPath := filepath.Join("..", "..", "testdata", "golden", "v10.7.5", "wal", "simple.log")
	data, err := os.ReadFile(goldenPath)
	if err != nil {
		t.Skipf("Golden file not found: %v (run golden fixture generation first)", err)
	}

	reader := NewReader(bytes.NewReader(data), nil, true /* checksum */, 0 /* log_num */)

	// Read the single record
	record, err := reader.ReadRecord()
	if err != nil {
		t.Fatalf("Failed to read record: %v", err)
	}

	// The record should be a WriteBatch containing key3=value3
	// WriteBatch format: 8-byte sequence + 4-byte count + entries
	if len(record) < 12 {
		t.Fatalf("Record too short: got %d bytes", len(record))
	}

	// Check sequence number (should be non-zero)
	// Bytes 0-7: sequence number (little-endian)
	// Bytes 8-11: count (little-endian)
	t.Logf("Record length: %d bytes", len(record))
	t.Logf("Record hex: %x", record)

	// Verify we get EOF on next read
	_, err = reader.ReadRecord()
	if err == nil {
		t.Fatal("Expected EOF after single record")
	}
}

// TestGoldenWALMulti tests reading a WAL file with the last entry (key5=value5).
func TestGoldenWALMulti(t *testing.T) {
	goldenPath := filepath.Join("..", "..", "testdata", "golden", "v10.7.5", "wal", "multi.log")
	data, err := os.ReadFile(goldenPath)
	if err != nil {
		t.Skipf("Golden file not found: %v (run golden fixture generation first)", err)
	}

	reader := NewReader(bytes.NewReader(data), nil, true /* checksum */, 0 /* log_num */)

	// Read the record
	record, err := reader.ReadRecord()
	if err != nil {
		t.Fatalf("Failed to read record: %v", err)
	}

	t.Logf("Multi record length: %d bytes", len(record))

	// Should contain key5 = value5
	if !bytes.Contains(record, []byte("key5")) {
		t.Errorf("Expected record to contain 'key5', got: %x", record)
	}
}

// TestGoldenWALFragmented tests reading a WAL file with a large record that spans
// multiple blocks (>32KB).
func TestGoldenWALFragmented(t *testing.T) {
	goldenPath := filepath.Join("..", "..", "testdata", "golden", "v10.7.5", "wal", "fragmented.log")
	data, err := os.ReadFile(goldenPath)
	if err != nil {
		t.Skipf("Golden file not found: %v (run golden fixture generation first)", err)
	}

	if len(data) < BlockSize {
		t.Skipf("Fragmented file too small (%d bytes), expected >%d", len(data), BlockSize)
	}

	reader := NewReader(bytes.NewReader(data), nil, true /* checksum */, 0 /* log_num */)

	// Read the large record
	record, err := reader.ReadRecord()
	if err != nil {
		t.Fatalf("Failed to read fragmented record: %v", err)
	}

	// The record should be large (contains ~50KB of 'x' characters)
	t.Logf("Fragmented record length: %d bytes", len(record))

	// Should contain "largekey"
	if !bytes.Contains(record, []byte("largekey")) {
		t.Errorf("Expected record to contain 'largekey'")
	}

	// Should contain many 'x' characters
	xCount := bytes.Count(record, []byte("x"))
	if xCount < 40000 {
		t.Errorf("Expected at least 40000 'x' characters, got %d", xCount)
	}
}

// TestGoldenWALWriteReadRoundTrip verifies our Writer produces output that our Reader can parse.
func TestGoldenWALWriteReadRoundTrip(t *testing.T) {
	testCases := []struct {
		name    string
		records [][]byte
	}{
		{
			name:    "single small record",
			records: [][]byte{[]byte("hello world")},
		},
		{
			name:    "multiple records",
			records: [][]byte{[]byte("one"), []byte("two"), []byte("three")},
		},
		{
			name: "varying sizes",
			records: [][]byte{
				[]byte("short"),
				bytes.Repeat([]byte("medium"), 100),
				bytes.Repeat([]byte("large"), 10000),
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			var buf bytes.Buffer
			writer := NewWriter(&buf, 1 /* logNumber */, false /* recyclable */)

			// Write all records
			for _, rec := range tc.records {
				if _, err := writer.AddRecord(rec); err != nil {
					t.Fatalf("AddRecord failed: %v", err)
				}
			}

			// Read them back
			reader := NewReader(bytes.NewReader(buf.Bytes()), nil, true, 1)
			for i, expected := range tc.records {
				got, err := reader.ReadRecord()
				if err != nil {
					t.Fatalf("ReadRecord %d failed: %v", i, err)
				}
				if !bytes.Equal(got, expected) {
					t.Errorf("Record %d mismatch: got %d bytes, want %d bytes", i, len(got), len(expected))
				}
			}
		})
	}
}
