// sst_file_writer.go implements external SST file writing.
//
// SstFileWriter creates SST files that can be ingested into the database
// using IngestExternalFile. Keys must be added in sorted order.
//
// Reference: RocksDB v10.7.5
//   - include/rocksdb/sst_file_writer.h
//   - table/sst_file_writer.cc
package db

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"sync"

	"github.com/aalhour/rockyardkv/internal/checksum"
	"github.com/aalhour/rockyardkv/internal/compression"
	"github.com/aalhour/rockyardkv/internal/dbformat"
	"github.com/aalhour/rockyardkv/internal/rangedel"
	"github.com/aalhour/rockyardkv/internal/table"
)

// SST File Writer errors
var (
	// ErrSstWriterNotOpened is returned when trying to use a writer that hasn't been opened.
	ErrSstWriterNotOpened = errors.New("sst: file writer not opened")

	// ErrSstWriterAlreadyOpened is returned when trying to open an already opened writer.
	ErrSstWriterAlreadyOpened = errors.New("sst: file writer already opened")

	// ErrSstWriterAlreadyFinished is returned when trying to add to a finished writer.
	ErrSstWriterAlreadyFinished = errors.New("sst: file writer already finished")

	// ErrSstWriterKeyOutOfOrder is returned when keys are added out of order.
	ErrSstWriterKeyOutOfOrder = errors.New("sst: keys must be added in sorted order")

	// ErrSstWriterEmptyFile is returned when trying to finish a file with no entries.
	ErrSstWriterEmptyFile = errors.New("sst: cannot finish file with no entries")
)

// ExternalSstFileInfo contains information about an SST file created by SstFileWriter.
// This matches the C++ RocksDB ExternalSstFileInfo structure.
type ExternalSstFileInfo struct {
	// FilePath is the path to the SST file.
	FilePath string

	// SmallestKey is the smallest user key in the file.
	SmallestKey []byte

	// LargestKey is the largest user key in the file.
	LargestKey []byte

	// SmallestRangeDelKey is the smallest range deletion user key (if any).
	SmallestRangeDelKey []byte

	// LargestRangeDelKey is the largest range deletion user key (if any).
	LargestRangeDelKey []byte

	// SequenceNumber is the sequence number assigned to all keys in the file.
	// For externally created files, this is typically 0.
	SequenceNumber uint64

	// FileSize is the size of the file in bytes.
	FileSize uint64

	// NumEntries is the number of point entries (Put/Delete) in the file.
	NumEntries uint64

	// NumRangeDelEntries is the number of range deletion entries in the file.
	NumRangeDelEntries uint64

	// FileChecksum is the checksum of the file (if computed).
	FileChecksum string

	// Version is the SST file format version.
	Version int32
}

// SstFileWriterOptions configures the SstFileWriter.
type SstFileWriterOptions struct {
	// Comparator for key ordering. If nil, uses bytewise comparator.
	Comparator Comparator

	// Compression type for the SST file.
	Compression compression.Type

	// BlockSize is the target size for data blocks.
	BlockSize int

	// BlockRestartInterval is the number of keys between restart points.
	BlockRestartInterval int

	// FilterBitsPerKey for creating bloom filters. 0 means no filter.
	FilterBitsPerKey int

	// FormatVersion is the SST file format version.
	FormatVersion uint32
}

// DefaultSstFileWriterOptions returns default options for SstFileWriter.
func DefaultSstFileWriterOptions() SstFileWriterOptions {
	return SstFileWriterOptions{
		Comparator:           nil, // Uses bytewise comparator
		Compression:          compression.NoCompression,
		BlockSize:            4096,
		BlockRestartInterval: 16,
		FilterBitsPerKey:     10, // Default bloom filter bits
		FormatVersion:        3,  // Use version 3 for best compatibility (no value_delta_encoding)
	}
}

// SstFileWriter creates SST files that can be ingested into a database.
// All keys in files generated by SstFileWriter have sequence number = 0.
//
// This class is NOT thread-safe.
//
// Usage:
//
//	writer, _ := NewSstFileWriter(opts)
//	writer.Open("/path/to/file.sst")
//	writer.Put(key1, value1)
//	writer.Put(key2, value2)
//	info, _ := writer.Finish()
//
// Keys MUST be added in sorted order according to the comparator.
type SstFileWriter struct {
	mu sync.Mutex

	// Options
	opts SstFileWriterOptions

	// File state
	filePath string
	file     *os.File
	builder  *table.TableBuilder

	// Key tracking
	lastKey     []byte
	smallestKey []byte
	largestKey  []byte

	// Range deletion tracking
	rangeTombstones     *rangedel.TombstoneList
	smallestRangeDelKey []byte
	largestRangeDelKey  []byte

	// Counters
	numEntries         uint64
	numRangeDelEntries uint64

	// State
	opened   bool
	finished bool
}

// NewSstFileWriter creates a new SstFileWriter with the given options.
func NewSstFileWriter(opts SstFileWriterOptions) *SstFileWriter {
	if opts.BlockSize == 0 {
		opts.BlockSize = 4096
	}
	if opts.BlockRestartInterval == 0 {
		opts.BlockRestartInterval = 16
	}
	if opts.FormatVersion == 0 {
		opts.FormatVersion = 5
	}

	return &SstFileWriter{
		opts: opts,
	}
}

// Open prepares the writer to create an SST file at the given path.
func (w *SstFileWriter) Open(filePath string) error {
	w.mu.Lock()
	defer w.mu.Unlock()

	if w.opened {
		return ErrSstWriterAlreadyOpened
	}

	// Create the file
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("sst: failed to create file: %w", err)
	}

	// Create the table builder
	builderOpts := table.BuilderOptions{
		BlockSize:            w.opts.BlockSize,
		BlockRestartInterval: w.opts.BlockRestartInterval,
		Compression:          w.opts.Compression,
		FormatVersion:        w.opts.FormatVersion,
		FilterBitsPerKey:     w.opts.FilterBitsPerKey,
		ChecksumType:         checksum.TypeCRC32C,
	}

	w.file = file
	w.filePath = filePath
	w.builder = table.NewTableBuilder(file, builderOpts)
	w.opened = true
	w.finished = false

	// Reset state
	w.lastKey = nil
	w.smallestKey = nil
	w.largestKey = nil
	w.rangeTombstones = nil
	w.smallestRangeDelKey = nil
	w.largestRangeDelKey = nil
	w.numEntries = 0
	w.numRangeDelEntries = 0

	return nil
}

// Put adds a key-value pair to the SST file.
// Keys must be added in sorted order according to the comparator.
func (w *SstFileWriter) Put(key, value []byte) error {
	w.mu.Lock()
	defer w.mu.Unlock()

	if err := w.checkState(); err != nil {
		return err
	}

	// Verify key order
	if err := w.checkKeyOrder(key); err != nil {
		return err
	}

	// Create internal key with sequence number 0 and type Value
	internalKey := dbformat.NewInternalKey(key, 0, dbformat.TypeValue)

	// Add to builder
	if err := w.builder.Add(internalKey, value); err != nil {
		return err
	}

	// Update tracking
	w.updateKeyTracking(key)
	w.numEntries++

	return nil
}

// Delete adds a deletion marker for the key to the SST file.
// Keys must be added in sorted order according to the comparator.
func (w *SstFileWriter) Delete(key []byte) error {
	w.mu.Lock()
	defer w.mu.Unlock()

	if err := w.checkState(); err != nil {
		return err
	}

	// Verify key order
	if err := w.checkKeyOrder(key); err != nil {
		return err
	}

	// Create internal key with sequence number 0 and type Deletion
	internalKey := dbformat.NewInternalKey(key, 0, dbformat.TypeDeletion)

	// Add to builder with empty value
	if err := w.builder.Add(internalKey, nil); err != nil {
		return err
	}

	// Update tracking
	w.updateKeyTracking(key)
	w.numEntries++

	return nil
}

// DeleteRange adds a range deletion [startKey, endKey) to the SST file.
// Range deletions are stored in a separate meta-block.
func (w *SstFileWriter) DeleteRange(startKey, endKey []byte) error {
	w.mu.Lock()
	defer w.mu.Unlock()

	if err := w.checkState(); err != nil {
		return err
	}

	// Validate range
	cmp := w.compareKeys(startKey, endKey)
	if cmp >= 0 {
		return fmt.Errorf("sst: invalid range deletion: start key must be less than end key")
	}

	// Add to range tombstones list
	if w.rangeTombstones == nil {
		w.rangeTombstones = rangedel.NewTombstoneList()
	}
	w.rangeTombstones.AddRange(startKey, endKey, 0)

	// Update range deletion key tracking
	if w.smallestRangeDelKey == nil || w.compareKeys(startKey, w.smallestRangeDelKey) < 0 {
		w.smallestRangeDelKey = append([]byte(nil), startKey...)
	}
	if w.largestRangeDelKey == nil || w.compareKeys(endKey, w.largestRangeDelKey) > 0 {
		w.largestRangeDelKey = append([]byte(nil), endKey...)
	}

	w.numRangeDelEntries++

	return nil
}

// Merge adds a merge operand for the key to the SST file.
// Keys must be added in sorted order according to the comparator.
func (w *SstFileWriter) Merge(key, value []byte) error {
	w.mu.Lock()
	defer w.mu.Unlock()

	if err := w.checkState(); err != nil {
		return err
	}

	// Verify key order
	if err := w.checkKeyOrder(key); err != nil {
		return err
	}

	// Create internal key with sequence number 0 and type Merge
	internalKey := dbformat.NewInternalKey(key, 0, dbformat.TypeMerge)

	// Add to builder
	if err := w.builder.Add(internalKey, value); err != nil {
		return err
	}

	// Update tracking
	w.updateKeyTracking(key)
	w.numEntries++

	return nil
}

// Finish completes the SST file and returns information about it.
// After calling Finish, the writer cannot be used again without calling Open.
func (w *SstFileWriter) Finish() (*ExternalSstFileInfo, error) {
	w.mu.Lock()
	defer w.mu.Unlock()

	if !w.opened {
		return nil, ErrSstWriterNotOpened
	}
	if w.finished {
		return nil, ErrSstWriterAlreadyFinished
	}

	// Check if we have any entries
	if w.numEntries == 0 && w.numRangeDelEntries == 0 {
		w.cleanup()
		return nil, ErrSstWriterEmptyFile
	}

	// Add range tombstones to the builder
	if w.rangeTombstones != nil && !w.rangeTombstones.IsEmpty() {
		if err := w.builder.AddRangeTombstones(w.rangeTombstones); err != nil {
			w.cleanup()
			return nil, fmt.Errorf("sst: failed to add range tombstones: %w", err)
		}
	}

	// Finish the table
	if err := w.builder.Finish(); err != nil {
		w.cleanup()
		return nil, fmt.Errorf("sst: failed to finish table: %w", err)
	}

	// Get file size
	fileInfo, err := w.file.Stat()
	if err != nil {
		w.cleanup()
		return nil, fmt.Errorf("sst: failed to stat file: %w", err)
	}

	// Close the file
	if err := w.file.Close(); err != nil {
		return nil, fmt.Errorf("sst: failed to close file: %w", err)
	}

	w.finished = true

	// Build the file info
	info := &ExternalSstFileInfo{
		FilePath:            w.filePath,
		SmallestKey:         append([]byte(nil), w.smallestKey...),
		LargestKey:          append([]byte(nil), w.largestKey...),
		SmallestRangeDelKey: append([]byte(nil), w.smallestRangeDelKey...),
		LargestRangeDelKey:  append([]byte(nil), w.largestRangeDelKey...),
		SequenceNumber:      0,
		FileSize:            uint64(fileInfo.Size()),
		NumEntries:          w.numEntries,
		NumRangeDelEntries:  w.numRangeDelEntries,
		Version:             int32(w.opts.FormatVersion),
	}

	return info, nil
}

// FileSize returns the current file size in bytes.
func (w *SstFileWriter) FileSize() uint64 {
	w.mu.Lock()
	defer w.mu.Unlock()

	if !w.opened || w.builder == nil {
		return 0
	}
	return w.builder.FileSize()
}

// Abandon abandons the current file and cleans up resources.
func (w *SstFileWriter) Abandon() error {
	w.mu.Lock()
	defer w.mu.Unlock()

	if !w.opened {
		return nil
	}

	w.cleanup()
	return nil
}

// checkState verifies the writer is in a valid state for adding entries.
func (w *SstFileWriter) checkState() error {
	if !w.opened {
		return ErrSstWriterNotOpened
	}
	if w.finished {
		return ErrSstWriterAlreadyFinished
	}
	return nil
}

// checkKeyOrder verifies that the key is greater than the last added key.
func (w *SstFileWriter) checkKeyOrder(key []byte) error {
	if w.lastKey == nil {
		return nil
	}

	cmp := w.compareKeys(w.lastKey, key)
	if cmp >= 0 {
		return ErrSstWriterKeyOutOfOrder
	}

	return nil
}

// updateKeyTracking updates the smallest/largest key tracking.
func (w *SstFileWriter) updateKeyTracking(key []byte) {
	// Update lastKey
	w.lastKey = append(w.lastKey[:0], key...)

	// Update smallest/largest
	if w.smallestKey == nil {
		w.smallestKey = append([]byte(nil), key...)
	}
	w.largestKey = append(w.largestKey[:0], key...)
}

// compareKeys compares two keys using the configured comparator.
func (w *SstFileWriter) compareKeys(a, b []byte) int {
	if w.opts.Comparator != nil {
		return w.opts.Comparator.Compare(a, b)
	}
	return bytes.Compare(a, b)
}

// cleanup closes the file and removes it.
func (w *SstFileWriter) cleanup() {
	if w.file != nil {
		_ = w.file.Close()
		os.Remove(w.filePath)
		w.file = nil
	}
	w.builder = nil
	w.opened = false
	w.finished = false
}
