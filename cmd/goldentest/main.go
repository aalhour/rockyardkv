// Golden test framework for RockyardKV
//
// This tool verifies bit-level compatibility between RockyardKV (Go) and
// RocksDB (C++) by testing that each implementation can read files generated
// by the other.
//
// Tests fall into two categories:
// 1. Go reads C++: Verify Go can parse files generated by C++ RocksDB
// 2. C++ reads Go: Verify C++ RocksDB tools can parse files generated by Go
//
// The tool uses pre-generated fixtures and the RocksDB ldb/sst_dump binaries
// for verification.
//
// Reference: RocksDB v10.7.5
//   - tools/ldb.cc (ldb tool)
//   - tools/sst_dump.cc (sst_dump tool)
//   - tools/generate_golden_fixtures.cc (fixture generator)
package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

var (
	fixturesDir = flag.String("fixtures", "", "Directory containing C++ generated fixtures")
	outputDir   = flag.String("output", "", "Directory to write Go generated fixtures")
	ldbPath     = flag.String("ldb", "", "Path to RocksDB ldb binary")
	sstDumpPath = flag.String("sst-dump", "", "Path to RocksDB sst_dump binary")
	verbose     = flag.Bool("v", false, "Verbose output")
)

// TestResult captures the outcome of a single test
type TestResult struct {
	Name     string
	Passed   bool
	Duration time.Duration
	Error    string
}

// TestSuite groups related tests
type TestSuite struct {
	Name    string
	Results []TestResult
}

func main() {
	flag.Parse()

	if *fixturesDir == "" || *outputDir == "" {
		fmt.Println("Usage: golden_test -fixtures <dir> -output <dir> [-ldb <path>] [-sst-dump <path>]")
		flag.PrintDefaults()
		os.Exit(1)
	}

	// Ensure directories exist
	if err := os.MkdirAll(*outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create output directory: %v\n", err)
		os.Exit(1)
	}

	suites := []TestSuite{
		runWALTests(),
		runManifestTests(),
		runBlockTests(),
		runSSTTests(),
		runDatabaseTests(),
	}

	// Print results
	fmt.Println("\n" + strings.Repeat("=", 70))
	fmt.Println("GOLDEN TEST RESULTS")
	fmt.Println(strings.Repeat("=", 70))

	totalPassed := 0
	totalFailed := 0

	for _, suite := range suites {
		passed := 0
		failed := 0
		for _, r := range suite.Results {
			if r.Passed {
				passed++
				totalPassed++
			} else {
				failed++
				totalFailed++
			}
		}
		fmt.Printf("\n%s: %d passed, %d failed\n", suite.Name, passed, failed)
		for _, r := range suite.Results {
			status := "✓"
			if !r.Passed {
				status = "✗"
			}
			fmt.Printf("  %s %s (%v)\n", status, r.Name, r.Duration.Round(time.Millisecond))
			if !r.Passed && r.Error != "" {
				fmt.Printf("      Error: %s\n", r.Error)
			}
		}
	}

	fmt.Println(strings.Repeat("=", 70))
	fmt.Printf("TOTAL: %d passed, %d failed\n", totalPassed, totalFailed)

	if totalFailed > 0 {
		os.Exit(1)
	}
}

// runWALTests verifies WAL file format compatibility
func runWALTests() TestSuite {
	suite := TestSuite{Name: "WAL Format Tests"}

	// Test 1: Go generates WAL, verify with ldb (most important test)
	suite.Results = append(suite.Results, runTest("Go writes WAL, C++ reads database", func() error {
		return verifyGoGeneratesWAL()
	}))

	// Note: Reading C++ WAL directly is not reliable because after compaction
	// the WAL is often empty (0 bytes). The database compatibility test
	// implicitly verifies WAL format through the full open/recovery path.

	return suite
}

// runManifestTests verifies MANIFEST file format compatibility
func runManifestTests() TestSuite {
	suite := TestSuite{Name: "MANIFEST Format Tests"}

	// Test 1: Go reads C++ MANIFEST from the simple_db
	suite.Results = append(suite.Results, runTest("Go reads C++ MANIFEST", func() error {
		// Find MANIFEST files in the simple_db
		dbPath := filepath.Join(*fixturesDir, "sst", "simple_db")
		files, err := filepath.Glob(filepath.Join(dbPath, "MANIFEST-*"))
		if err != nil || len(files) == 0 {
			return fmt.Errorf("no MANIFEST files found in %s", dbPath)
		}
		return verifyGoReadsManifest(files[0])
	}))

	// Test 2: C++ opens Go-generated database (implicitly verifies MANIFEST)
	// This is tested in the Full Database Tests section
	// The fact that ldb can scan the Go-generated database proves MANIFEST compatibility

	return suite
}

// runBlockTests verifies data block format compatibility
// Note: Block format is implicitly tested via SST file reading
func runBlockTests() TestSuite {
	suite := TestSuite{Name: "Block Format Tests"}

	// Block format is tested implicitly through SST file reading
	// The SST tests already verify block parsing
	suite.Results = append(suite.Results, runTest("Block format verified via SST reading", func() error {
		// This is a placeholder - blocks are tested through SST file reading
		return nil
	}))

	return suite
}

// runSSTTests verifies SST file format compatibility
func runSSTTests() TestSuite {
	suite := TestSuite{Name: "SST Format Tests"}

	// Test 1: Go reads C++ SST files
	suite.Results = append(suite.Results, runTest("Go reads C++ SST files", func() error {
		dbPath := filepath.Join(*fixturesDir, "sst", "simple_db")
		return verifyGoReadsSST(dbPath)
	}))

	// Test 2: Go generates SST, verify with sst_dump
	suite.Results = append(suite.Results, runTest("C++ reads Go-generated SST", func() error {
		return verifyGoGeneratesSST()
	}))

	return suite
}

// runDatabaseTests verifies complete database compatibility
func runDatabaseTests() TestSuite {
	suite := TestSuite{Name: "Full Database Tests"}

	// Test 1: Go opens C++ database
	suite.Results = append(suite.Results, runTest("Go opens C++ database", func() error {
		dbPath := filepath.Join(*fixturesDir, "sst", "simple_db")
		return verifyGoOpensDatabase(dbPath)
	}))

	// Test 2: C++ opens Go-generated database
	suite.Results = append(suite.Results, runTest("C++ opens Go-generated database", func() error {
		return verifyCppOpensGoDatabase()
	}))

	return suite
}

// runTest executes a test function and captures the result
func runTest(name string, fn func() error) TestResult {
	if *verbose {
		fmt.Printf("Running: %s...\n", name)
	}

	start := time.Now()
	err := fn()
	duration := time.Since(start)

	result := TestResult{
		Name:     name,
		Duration: duration,
		Passed:   err == nil,
	}
	if err != nil {
		result.Error = err.Error()
	}

	return result
}

// runLdb runs the ldb tool with the given arguments
func runLdb(args ...string) (string, error) {
	if *ldbPath == "" {
		return "", fmt.Errorf("ldb path not specified")
	}

	cmd := exec.Command(*ldbPath, args...)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("ldb failed: %w\nstderr: %s", err, stderr.String())
	}

	return stdout.String(), nil
}

// runSstDump runs the sst_dump tool with the given arguments
func runSstDump(args ...string) (string, error) {
	if *sstDumpPath == "" {
		return "", fmt.Errorf("sst_dump path not specified")
	}

	cmd := exec.Command(*sstDumpPath, args...)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("sst_dump failed: %w\nstderr: %s", err, stderr.String())
	}

	return stdout.String(), nil
}
